File encryption for small files that are rewritten completely when changed.

VERSION 0010
file format:
64bytes unencrypted header
variable number of camellia 256 encrypted blocks in cbc mode

header format:
8 bytes magic string
4 bytes version string
camelia256::saltsize byte salt
camelia256::blocksize bytes iv
size = 8 + 4 + 16 + 16 = 44

TODO: VERSION 0020
-> leaves exactly 20 bytes for sha1 HMAC. (TODO)
-> 8 bytes for timestamp needed too

camelia256::saltsize = 16
camelia256::blocksize = 16
camelia256::keysize = 32


usage:

A. create file:
1. fill salt/iv with rng from /dev/random
2. write header to file

B. read file:
1. read existing iv/salt from header
2. take user provided password and salt from file header to generate a
   key of length camelia256::keysize with pbkdf2_pkcs5 algorithm
3. read the whole encrypted file in a buffer and decrypt using key and iv

C. write file:
1. read existing iv/salt from header
2. take user provided password and salt from file header to generate a
   key of length camelia256::keysize with pbkdf2_pkcs5 algorithm
3. get new iv from /dev/random
4. encrypt provided buffer using key and the iv from step C.3. update and
   write header and all blocks to file.


Questions:
Is it ok to reuse the iv?
   No.
-> http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Initialization_vector_.28IV.29
   "...in most cases, it is important that an initialization vector is
   never reused under the same key.
   For CBC and CFB, reusing an IV leaks some information about the
   first block of plaintext, and about any common prefix shared by the
   two messages.
   For OFB and CTR, reusing an IV completely destroys security.[6]
   This can be seen because both modes effectively create a bitstream
   that is XORed with the plaintext, and this bitstream is dependent
   on the password and IV only.
   Reusing a bitstream destroys security.[8] In CBC mode, the IV must,
   in addition, be unpredictable at encryption time; in particular,
   the (previously) common practice of re-using the last ciphertext
   block of a message as the IV for the next message is insecure (for
   example, this method was used by SSL 2.0).
   If an attacker knows the IV (or the previous block of ciphertext)
   before he specifies the next plaintext, he can check his guess
   about plaintext of some block that was encrypted with the same key
   before (this is known as the TLS CBC IV attack)."

Is it ok to reuse the salt?


Possible improvements:
Generate master_key with pbkdf2_pkcs5 alorithm using stored constant salt+password as input.
salt can be reused.
-> how to get unique iv from this master_key?
http://security.stackexchange.com/a/31544
http://security.stackexchange.com/a/31542

Use a different cpher mode like GCM or EAX: IV can be a counter, no padding necessary.
-> would make file protocoll/io easier.
-> openssl support?
http://security.stackexchange.com/a/49034

provide integrity with a MAC
  "CBC does not ensure integrity. Usually, when you need to encrypt
  (for confidentiality), you also need to reliably detect hostile
  alterations. For that, you need a MAC. Assembling a MAC and
  encryption is tricky."
using GCM or EAX mode would make this unnecessary:
http://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac

http://security.stackexchange.com/a/20301
"An HMAC by itself does not provide message integrity. It can be one
of the components in a protocol that provides integrity.(...)One
possible way to provide storage integrity in this scenario would be to
include the file name and a version number as part of the data whose
MAC is computed; Alice would need to remember the latest version
number of each file so as to verify that she is not given stale
data. Another way to ensure integrity would be for Alice to remember
the MAC of each file"
  - HMAC provides authenticity
  - for integrity a version number/date of last encryption should be
    appended to file header, or in the encrypted Ä‡ontent. If it is in
    the file header, it must be included in hmac construction.
    Integrity is given when user is shown the time of last encryption
    and checks if it is valid. Integrity is in this case only
    verified after decryption. Authenticity before decryption.